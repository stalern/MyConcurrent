# Java中的`synchronized`关键字

### 使用方式
`synchronized`可以修饰代码块，也可以修饰方法。对于`static`方法来说，其使用的是类锁，即该对象所对应的class类；对于其他方法，其使用的是该实例对象锁。等价于代码块中的this
### 原理
* 对于修饰方法来说，会在字节码的flags中表明为ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放
* 当修饰代码块时，会在字节码中通过 `monitorenter` 和 `monitorexit` 执行来进行加锁。当线程执行到 `monitorenter` 的时候要先获得所锁，才能执行后面的方法。当线程执行到 `monitorexit` 的时候则要释放锁。每个对象自身维护这一个被加锁次数的计数器，当计数器数字为 0 时表示可以被任意线程获得锁。当计数器不为 0 时，只有获得锁的线程才能再次获得锁。即可重入锁。
### 锁优化
对于synchronized来说，在JDK1.6之后，优化了相当一部分内容，其中有自旋锁，锁消除，偏向锁，锁粗化，

* 偏向锁：**经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。**当一个线程访问同步块并获取锁时，会在**对象头和栈帧中的锁记录里存储偏向的线程ID**，以后该线程在**进入和退出同步块时不需要进行 CAS 操作来加锁和解锁**，只需简单的测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。测试成功则获得该锁，失败会去检查MarkWord中**偏向锁的标志**。如果标志为0，则用CAS竞争锁。如果设置为1，即当前是偏向锁， 则尝试使用 CAS 将对象头的偏向锁指向当前线程。
* 轻量级锁：偏向锁膨胀为轻量级锁之后，线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁，当自旋达到一定次数之后未获得锁，便会膨胀成重量级锁。
* 适应性自旋锁：线程加锁的时间一般都很短，所以下一个需要获得锁的线程等一下在阻塞，这个等一下的过程就叫自旋。这种优化方法叫自旋锁。而所谓的自适应自旋锁就是说线程等待的时间不是固定的。自旋锁在1.4就有，只不过默认的是关闭的，jdk1.6是默认开启的

**那还有其他编译器的锁优化吗，比如锁粗化**

同时还有锁粗化和轻量级锁

* 锁粗化：JIT优化，防止对同一个对象连续加锁和解锁。增大了锁的粒度
* 锁消除：JIT通过逃逸分析技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。 如果是，则消除synchronized，即不用加锁

